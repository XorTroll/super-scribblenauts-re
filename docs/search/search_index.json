{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Super Scribblenauts (EU) documentation","text":"<p>Hi! I'm XorTroll, welcome to my Super Scribblenauts (EU) documentation!</p> <p>This page documents everything known about the game's logic and assets. It will be progresivelly filled as more stuff gets decompiled/reversed/understood ;)</p> <p>Feel free to check the existing tools and code at the the GitHub repository.</p>"},{"location":"fs/","title":"Game filesystem","text":""},{"location":"fs/#game-files","title":"Game files","text":"<p>These are all the files present in Super Scribblenauts's Nitro FS:</p> <ul> <li> <p><code>dwc/utility.bin</code>: DWC utility data file, present in any DS games using Download Play</p> </li> <li> <p><code>audio.sdat</code>: SDAT sound data file (format used by most DS games)</p> </li> <li> <p><code>audio.sadl</code>: C header file with SDAT sound index values: likely left by mistake, just a regular header file included in the code when compiling</p> <p>Note: for quite a lot of DS games, these kind of intermediate-build files are mistakengly left in the Nitro FS</p> </li> <li> <p><code>1i</code> and <code>1p</code>: these files contain everything else in the game, in a custom filesystem format explained below.</p> </li> </ul>"},{"location":"fs/#filesystem-format","title":"Filesystem format","text":"<p>The files <code>1i</code> and <code>1p</code> (known as index and package files) together contain a filesystem, in a unique format used by this game (even the original Scribblenauts did it differently, storing files plainly in the Nitro FS).</p> <p>Note: Scribblenauts Remix shares the exact same filesystem format, where the index and package files are the two OBB files found in the game data.</p> <p>There is a total of <code>33383</code> files in the release game. Files contain no names, they are referred to by their index (file <code>0</code>, file <code>1</code> ... up to file <code>33382</code>), internally known as their file ID. There are several files where their file IDs are hardcoded in-game, while various other formats internally contain other sub-file IDs for further content.</p> <p>The file <code>1i</code> contains all the file offsets. It has the following binary format:</p> <pre><code>u32 file_count;\nu32 file_offsets[file_count + 1];\n</code></pre> <p>There is an additional offset, which (at least in the release game) is just the repeated previous offset. This is likely done so that for the <code>i</code>-th file, the file size can always be computed as:</p> <pre><code>u32 file_size_i = file_offsets[i + 1] - file_offsets[i];\n</code></pre> <p>The game does indeed compute file sizes this way, expecting that intentional extra offset to be contained in <code>1i</code>.</p> <p>Various files are empty in the release game (the file offset is the same as the next file offset, thus the file has size <code>0</code>).</p> <p>File offsets found in <code>1i</code> are absolute offsets of file <code>1p</code>, which contains file data. Each file data is ended by a byte indicating whether it is compressed:</p> <pre><code>// ...\n\n// current offset: file_offsets[i]\nu8 file_i_data[file_size_i];\nu8 file_i_comp_type; // 0 if plaintext, 1 if LZ77-compressed\n\n// current offset: file_offsets[i+1]\nu8 file_ip1_data[file_size_ip1];\nu8 file_ip1_comp_type;\n\n// ...\n</code></pre> <p>Note: unlike other file formats (from the SDK iself, and so on), binary formats specific to this game are not designed with any alignment/padding considerations, as can be seen by this filesystem data format (the final byte is always put after file data)</p> <p>The release game has various different functions to read file data. Some functions read the entire data in an allocated buffer, while in other places, file reading is done \"manually\" by pretty much making raw reads to <code>1p</code>.</p>"},{"location":"lang/","title":"Languages","text":"<p>The game has its own set of values for storing the active gameplay language:</p> Language Value English 0 Dutch 1 French 2 German 3 Italian 4 Spanish 5 <p>The values are almost equal to DS firmware values, but <code>0</code> and <code>1</code> are different (in DS firmware, <code>0</code> corresponds to Japanese and <code>1</code> to English).</p> <p>There is no support for Japanese (probably since the entire writing/word/object/adjective system would have needed to be entirely remade for Japanese writing), and there is support for Dutch language, despite DS(i) consoles never providing support for it.</p> <p>The game has an option for changing the language (although it initially defaults to the console language, converting the firmware value to this values), so Dutch can be chosen there by the end user.</p>"},{"location":"game/font/","title":"Font file","text":""},{"location":"game/font/#file-format","title":"File format","text":"<p>TODO</p>"},{"location":"game/font/#fonts","title":"Fonts","text":"Font description File ID Width Height \"Default\" font, large 891 15 22 \"Default\" font, medium 893 11 14 \"Default\" font, small 896 9 12 \"Default\" font variant, large 892 15 22 \"Default\" font variant, medium 894 11 14 \"Default\" font variant, small 897 9 12 \"Alternative\" font 895 6 8"},{"location":"game/gui/","title":"GUI files","text":"<p>TODO</p>"},{"location":"game/sprite/","title":"Sprite files","text":"<p>TODO</p>"},{"location":"game/text-list/","title":"Text list file","text":""},{"location":"game/text-list/#file-format","title":"File format","text":"<p>Files containing texts/messages have the following format:</p> <pre><code>u8 text_count_per_lang;\n{\n    char text_1[...];\n    char '\\n';\n    char text_2[...];\n    char '\\n';\n    // ...\n} texts_english;\n{\n    // ...\n} texts_dutch;\n\n// ...\n</code></pre> <p>There is an initial byte containing the number of texts (per language). The remaining contents are all text strings, separated by newlines (character <code>0x0A</code> or <code>'\\n'</code>). No further separation is done to indicate which strings belong to which language, they are all in order: all English strings, followed by all Dutch strings and so on (see languages) for each language.</p> <p>Note that, like with filesystem offsets, the last string will also end in a newline (basically, the newline is the ending indicator for every string).</p>"},{"location":"game/text-list/#text-format-escapes","title":"Text format / escapes","text":"<p>A unique property of Super Scribblenauts' strings is that they are all always uppercase (take a look at every single dialog/message/button when playing the game).</p> <p>This is, in fact, somewhat intentional or taken advantage of: certain lowercase characters are internally parsed as special operations on the string:</p> Character Action Example text c Center cDEMOc i Use alternative font iDEMOi l Use large \"default\" font lDEMOl m Use medium \"default\" font mDEMOm n Align left nDEMOn o Align right oDEMOo <p>Note that, by default, the start \"default\" font is used (see fonts).</p> <p>There is still no clear difference between texts that only start with the escape characters (like \"ciHELLO\") as opposed to texts that start and end with it (like \"ciHELLOic\", or maybe even \"ciHELLOci\"...?).</p>"},{"location":"game/text-list/#text-list-files","title":"Text list files","text":"<p>TODO</p>"},{"location":"objnaut/adjective/","title":"Adjective files","text":"<p>TODO</p>"},{"location":"objnaut/animation/","title":"Animation files","text":"<p>TODO</p>"},{"location":"objnaut/attack/","title":"Attack files","text":"<p>TODO</p>"},{"location":"objnaut/dictionary/","title":"Dictionary files","text":"<p>This page describes the various file formats that together form a list/table/dictionary containing object/adjective entries.</p>"},{"location":"objnaut/dictionary/#nomenclature","title":"Nomenclature","text":"<p>In order to avoid any mixups with objects, adjectives and so on, the following terms are used throughout this docs:</p> <p>Note: the following names/terms come from debug symbols found in Scribblenauts Remix releases, but since the underlying formats are virtually identical (and the engine code is also almost identical) it is safe to assume these were used with Super Scribblenauts as well.</p> <ul> <li> <p>Object / Adjective: these are rather self explanatory, the two kinds of inputs the game supports.</p> </li> <li> <p>Word: generic term describing either objects or adjectives (note that they may even individually contain multiple \"words\", like <code>ROCKET LAUNCHER</code>), as in the invidual input pieces typed in Maxwell's notebook.</p> </li> <li> <p>Meaning: used occasionally since the same input might correspond to multiple matches, like <code>AMAZON</code> can be either the rainforest or the native people.</p> </li> <li> <p>Detail: additional text used by the game to distinguish matches: for example, <code>AMAZON</code> can be either <code>PLACE</code> or <code>PERSON</code>, as just mentioned above. The text is displayed in-game in parentheses, as in like <code>AMAZON (PLACE)</code>.</p> </li> </ul>"},{"location":"objnaut/dictionary/#files","title":"Files","text":"<p>For each language, both for objects and adjectives (separately), the game stores dictionary data in four different but related files (the last one containing details, only used for objects):</p> <ul> <li> <p>Dictionary file: contains the actual word entries.</p> </li> <li> <p>\"Word offset\" and \"Jump offset\" file: contain offsets to word entries in the dictionary file.</p> </li> </ul> <p>Both offset list files have the same format, and essentially order/index words in different orderings. The \"word table\" file lists them in alphabetical order, while the \"jump table\" file lists them in a somewhat arbitrary ordering, even containing empty word entries (see below).</p> <p>Note: the \"jump table\" list seems to contain (offsets to) word entries as the developers kept creating and adding them, since they seem to be clustered around particular topics: for instance, the first blob of non-empty words are all musical instruments, and similar topics arise throughout the list. Moreover, the empty word entries probably correspond to old/dev/beta/testing words that were discarded throughout development.</p> <ul> <li>Details file (only for objects): contains detail texts for words with multiple meanings.</li> </ul> <p>Note: despite having remarkably different roles in the game logic, objects and adjectives are treated together here since they practically share the same formats described in this page. In fact, game code contains four functions to get the hardcoded file ID for each file according to the system language, where for the three common object/adjective files, the functions take a <code>bool is_object</code> argument whether to return object or adjective dictionary file IDs.</p> <p>Note: file IDs for word table list files are far beyond the other mentioned files (for all languages), which might suggest that this table was added later into development.</p> <p>Note: offset indices in the jump table are known as object IDs or adjective IDs throughout the game code, and offset indices in the word table are known as word IDs.</p>"},{"location":"objnaut/dictionary/#dictionary-file-format","title":"Dictionary file format","text":""},{"location":"objnaut/dictionary/#character-dictionary","title":"Character dictionary","text":"<p>The file starts with a \"character dictionary\" section:</p> <pre><code>u8 char_dict_len;\nchar char_dict[char_dict_len];\nu32 word_count;\nu32 word_entry_start_offset_2d_table[char_dict_len * char_dict_len];\n</code></pre> <p>The character dictionary consists on a list of characters, that words below may start with: for instance, \"ABCDEFG...\".</p> <p>The dictionary is followed by the total number of words (coming after this section), and by a bi-dimensional array with entries for each character in the dictionary consisting on 32-bit absolute offsets of word entries below.</p> <p>For instance, if the dictionary had five characters \"ABCDE\", the bi-dimensional table would be an array of <code>5*5 = 25</code> 32-bit offsets, and it shall be understood in the following way:</p> A B C D E A Offset to first word with name \"AA...\" Same for \"AB...\" Same for \"AC...\" Same for \"AD...\" Same for \"AE...\" B Same for \"BA...\" Same for \"BB...\" Same for \"BC...\" Same for \"BD...\" Same for \"BE...\" C Same for \"CA...\" Same for \"CB...\" Same for \"CC...\" Same for \"CD...\" Same for \"CE...\" D Same for \"DA...\" Same for \"DB...\" Same for \"DC...\" Same for \"DD...\" Same for \"DE...\" E Same for \"EA...\" Same for \"EB...\" Same for \"EC...\" Same for \"ED...\" Same for \"EE...\" <p>Thus, the offset to the table offset for a two-letter prefix <code>MN...</code> is calculated by (as the game itself computes):</p> <pre><code>u32 offset_offset(MN) = (0x01 + 0x01 * Character count + 0x04) + 0x04 * (index(M) * &lt;character-count&gt; + index(N));\n</code></pre> <p>Where <code>index(X)</code> corresponds to the index of the letter <code>X</code> in the dictionary above (in game code, such an index is computed by a searching loop over dictionary characters).</p> <p>This system is likely intended for a quick lookup of words based on the first two letters of the word name.</p>"},{"location":"objnaut/dictionary/#word-entry","title":"Word entry","text":"<p>Each word entry follows the following format (and follow one after each other without any alignment/padding, as per usual with other file formats):</p> <pre><code>u8 total_entry_size;\nu8 name_len;\nchar name[name_len];\nu16 word_id;\nu16 unk_zero;\nu8 meaning_count;\nu16 file_id_per_meaning[meaning_count];\nu16 obj_adj_id_per_meaning[meaning_count];\nu16 unk_per_meaning[meaning_count];\n</code></pre> <p>TODO: is total entry size used by the game?</p> <p>Note: keep in mind that the way fields are stored for each meaning is not the usual one! all the fields are laid out as individual arrays (unlike regular behaviour when having an array of plain data structures, for instance)</p>"},{"location":"objnaut/dictionary/#jump-word-table-file-format","title":"Jump / Word table file format","text":"<p>These files just contain <code>u32</code> absolute word entry offsets for their corresponding dictionary file.</p> <p>The offset count doesn't have to match the actual word/total meaning count, since the files may contain invalid offsets: any zero-offset makes no sense as a file. The game explicitly checks that <code>offset != 0</code> when reading words, which shows that any zero-offsets indeed correspond to invalid/empty word entries in this lists.</p> <p>For jump table offsets, the offset might point to a different word. For instance, there is an word entry for <code>BOG</code> with a single meaning, and that meaning's entry in the jump table file points to a different word entry, the one for <code>SWAMP</code>: this pretty much serves as a synonym mechanism, so that multiple words can be dealt with a single root word (think of <code>PASTA</code>, and then many kinds of pasta like <code>MACARONI</code>, <code>FUSILLI</code>, <code>RIGATONI</code> merely point to <code>PASTA</code>), since the game ultimately seems to load object/adjective data based on their object/adjective IDs.</p>"},{"location":"objnaut/dictionary/#details-file-format","title":"Details file format","text":""},{"location":"objnaut/dictionary/#character-dictionary_1","title":"Character dictionary","text":"<p>This format also starts with a character dictionary + offset lookup table, similar to dictionary files:</p> <pre><code>u8 char_dict_len;\nchar char_dict[char_dict_len];\nu32 detail_entry_start_offset_table[char_dict_len];\n</code></pre> <p>Unlike with dictionary files, no total entry count is provided, and the lookup table is one-dimensional, providing lookup based on the first character of the word name.</p> <p>Note: the game never loads these files entry by entry in order to find the detail text of the meanings of a given word: instead, it jumps to the first-letter offset by the lookup table, and then compares the word name to each detail entry, checking entry by entry (which is why there is no real need of an \"entry count\" field) until it is found.</p>"},{"location":"objnaut/dictionary/#detail-entry","title":"Detail entry","text":"<p>Each detail entry follows the following format (and follow one after each other without any alignment/padding, as per usual):</p> <pre><code>u8 word_name_len;\nchar word_name[word_name_len];\nu8 meaning_count;\nu16 unk_obj_id_per_meaning[meaning_count];\nu8 detail_text_len_per_meaning[meaning_count];\nchar detail_text_per_meaning[detail_text_len_per_meaning][meaning_count];\n</code></pre>"},{"location":"objnaut/dictionary/#dictionary-file-ids","title":"Dictionary file IDs","text":""},{"location":"objnaut/dictionary/#objects","title":"Objects","text":"Language Dictionary file ID Word table file ID Jump table file ID Details file ID English 13220 32173 13251 13236 Dutch 13228 32171 13250 13235 French 13225 32175 13253 13238 German 13219 32176 13255 13240 Italian 13227 32177 13256 13241 Spanish 13221 32180 13262 13246 Unknown 24063 32172 24064 24073"},{"location":"objnaut/dictionary/#adjectives","title":"Adjectives","text":"Language Dictionary file ID Word table file ID Jump table file ID English 13267 32161 13282 Dutch 13275 32159 13281 French 13272 32163 13284 German 13266 32164 13290 Italian 13274 32165 13291 Spanish 13268 32168 13295 Unknown 24074 32160 24075"},{"location":"objnaut/object/","title":"Object files","text":"<p>Note: the following file format / fields have been reversed from Scribblenauts Remix symbols, which allowed to find out almost all type/enum/field names.</p> <p>TODO: put everything!</p>"},{"location":"objnaut/object/#header","title":"Header","text":""},{"location":"objnaut/object/#actions","title":"Actions","text":"<ul> <li> <p>ShowNotepad (unused by any objects)</p> </li> <li> <p>Enables/disables the bottom-screen HUD elements</p> </li> </ul>"},{"location":"objnaut/objnaut/","title":"Objectnaut","text":"<p>Objectnaut is the (official) name of the object/adjective system used in the Scribblenauts saga. The name can be found in interviews given by the game developers or in debug symbols found in Scribblenauts Remix.</p> <p>TODO: overall description, similarities/differences between games...</p>"},{"location":"objnaut/objnaut/#game-differences","title":"Game differences","text":"<ul> <li>In Super, internal buffers for text input/etc have a size of <code>128</code> characters, while this size is <code>256</code> in Remix.</li> </ul>"},{"location":"objnaut/objnaut/#details","title":"Details","text":""},{"location":"objnaut/objnaut/#temperature-system","title":"Temperature system","text":"<p>The temperature system is fairly limited.</p> <p>The only objects making use of the SetTemperature action are kitchen appliances (microwaves, ovens and so on) and are only used to heat. Food/objects are only frozen by literally using the <code>FROZEN</code> adjective.</p>"},{"location":"objnaut/objnaut/#triggers","title":"Triggers","text":"<p>OnCatchFire is only checked by <code>VOODOO DOLL</code>.</p> <p>OnSplit is only checked by <code>BEAVER</code>.</p>"},{"location":"objnaut/objnaut/#unused-features","title":"Unused features","text":""},{"location":"objnaut/objnaut/#triggers_1","title":"Triggers","text":"<p>The following triggers are never used by objects:</p> <ul> <li> <p>OnObjectSwap</p> </li> <li> <p>OnAttached</p> </li> <li> <p>OnDetached</p> </li> <li> <p>OnPhysicsRest</p> </li> <li> <p>ConditionAnd</p> </li> <li> <p>ConditionOr</p> </li> <li> <p>OnCheckVariable</p> </li> <li> <p>OnUpdate</p> </li> <li> <p>OnContained</p> </li> <li> <p>OnUncontained</p> </li> <li> <p>OnObjectAdded</p> </li> <li> <p>OnAiState</p> </li> <li> <p>OnObjectCountInArea</p> </li> <li> <p>OnVelocity</p> </li> <li> <p>OnHearSound</p> </li> <li> <p>TriggerGroup</p> </li> <li> <p>ConditionOiAnd</p> </li> <li> <p>OnAiUnequip</p> </li> <li> <p>OnExtinguishFire</p> </li> <li> <p>OnKickAdjective</p> </li> </ul>"},{"location":"objnaut/objnaut/#actions","title":"Actions","text":"<p>The following actions are never used by objects:</p> <ul> <li> <p>MoveTo</p> </li> <li> <p>MoveRelative</p> </li> <li> <p>AttachToShowNotepad</p> </li> <li> <p>DetachFromAll</p> </li> <li> <p>SetVariable</p> </li> <li> <p>SpawnObjectAt</p> </li> <li> <p>Cinematic</p> </li> <li> <p>ShowNotepad</p> </li> <li> <p>EncaseInIce</p> </li> <li> <p>SetStageObject</p> </li> <li> <p>EnableEntity</p> </li> <li> <p>EnableSFAnim</p> </li> <li> <p>RotateEntity</p> </li> <li> <p>ShowFeedback</p> </li> <li> <p>Lock</p> </li> <li> <p>SetInterruptFlag</p> </li> <li> <p>Untouchable</p> </li> <li> <p>ModifyLineOfSight</p> </li> </ul>"},{"location":"objnaut/texture/","title":"Object texture file","text":"<p>This is the texture/graphics format used by objects.</p> <p>It contains graphics for all body parts / limbs in the same file, and objects use <code>TexQuad</code> frames to locate pos/size of each limb:</p> <p></p> <p>Graphics data for the <code>ELEMENTAL</code> object. (For reference, <code>ELEMENTAL</code> object data is in file ID 25257, and its graphics data is in file ID 7303).</p>"},{"location":"objnaut/texture/#file-format","title":"File format","text":"<p>The file itself starts with its own color palette table, and is followed by its dimensions and graphics data:</p> <pre><code>u8 color_count;\nu16 colors[color_count];\nu8 width;\nu8 height;\nu8 char_data[width * height / 2];\n</code></pre>"},{"location":"objnaut/texture/#color-and-pixel-formats","title":"Color and pixel formats","text":"<p>Colors are <code>XBGR1555</code> format: 5-bits per color, where the final bit is ignored (see below how alpha is dealt with).</p> <p>The implicit format for graphic character data is 4BPP, hence each char data <code>u8</code> contains information for two pixels (low 4-bits for the first pixel, high 4-bits for the next one). Each of these 4-bit values is just a color index (index in the preceding color table).</p> <p>The first color is considered transparent by the game: although the first color table entry usually has a purple color (full red+blue color, <code>#FF00FF</code> if it were converted to RGB). In other words, if the 4-bit char data value is <code>0</code> for a given pixel, then that pixel is seen as transparent in-game.</p> <p>Note: this is something frequently seen as well in other DS games</p>"}]}