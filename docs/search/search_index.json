{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Super Scribblenauts (EU) documentation","text":"<p>Hi! I'm XorTroll, welcome to my Super Scribblenauts (EU) documentation!</p> <p>This page documents everything known about the game's logic and assets. It will be progresivelly filled as more stuff gets decompiled/reversed/understood ;)</p> <p>Feel free to check the existing tools and code at the the GitHub repository.</p>"},{"location":"fs/","title":"Game filesystem","text":""},{"location":"fs/#game-files","title":"Game files","text":"<p>These are all the files present in the game's Nitro FS:</p> <ul> <li> <p><code>dwc/utility.bin</code>: DWC utility data file, present in any DS games using Download Play</p> </li> <li> <p><code>audio.sdat</code>: SDAT sound data file (format used by most DS games)</p> </li> <li> <p><code>audio.sadl</code>: C header file with SDAT sound index values: likely left by mistake, just a regular header file included in the code when compiling</p> <p>Note: for quite a lot of DS games, these kind of intermediate-build files are mistakengly left in the Nitro FS</p> </li> <li> <p><code>1i</code> and <code>1p</code>: these files contain everything else in the game, in a custom filesystem format explained below</p> </li> </ul>"},{"location":"fs/#filesystem-format","title":"Filesystem format","text":"<p>The files <code>1i</code> and <code>1p</code> together contain a filesystem, in a unique format used by this game (even the original Scribblenauts did it differently, storing files plainly in the Nitro FS).</p> <p>There is a total of <code>33383</code> files in the release game. Files contain no names, they are referred to by their index (file <code>0</code>, file <code>1</code> ... up to file <code>33382</code>). There are only a few files where the file indices are hardcoded in-game, while various other formats internally contain other sub-file indices for other content.</p> <p>The file <code>1i</code> contains all the file offsets. It has the following binary format:</p> <pre><code>u32 file_count;\nu32 file_offsets[file_count + 1];\n</code></pre> <p>There is an additional offset, which (at least in the release game) is just the repeated previous offset. This is likely done so that for the <code>i</code>-th file, the file size can always be computed as:</p> <pre><code>u32 file_size_i = file_offsets[i + 1] - file_offsets[i];\n</code></pre> <p>The game does indeed compute file sizes this way, expecting that intentional extra offset to be contained in <code>1i</code>.</p> <p>Various files are empty in the release game (the file offset is the same as the next file offset, thus the file has size <code>0</code>).</p> <p>File offsets found in <code>1i</code> are absolute offsets of file <code>1p</code>, which contains file data. Each file data is ended by a byte indicating whether it is compressed:</p> <pre><code>// ...\n\n// current offset: file_offsets[i]\nu8 file_i_data[file_size_i];\nu8 file_i_comp_type; // 0 if plaintext, 1 if LZ77-compressed\n\n// current offset: file_offsets[i+1]\nu8 file_ip1_data[file_size_ip1];\nu8 file_ip1_comp_type;\n\n// ...\n</code></pre> <p>Note: unlike other file formats (from the SDK iself, and so on), binary formats specific to this game are not designed with any alignment/padding considerations, as can be seen by this filesystem data format (the final byte is always put after file data)</p> <p>The release game has various different functions to read file data. Some functions read the entire data in an allocated buffer, while in other places, file reading is done \"manually\" by pretty much making raw reads to <code>1p</code>.</p>"},{"location":"lang/","title":"Languages","text":"<p>The game has its own set of values for storing the active gameplay language:</p> Language Value English 0 Dutch 1 French 2 German 3 Italian 4 Spanish 5 <p>The values are almost equal to DS firmware values, but <code>0</code> and <code>1</code> are different (in DS firmware, <code>0</code> corresponds to Japanese and <code>1</code> to English).</p> <p>There is no support for Japanese (probably since the entire writing/word/object/adjective system would have needed to be entirely remade for Japanese writing), and there is support for Dutch language, despite DS(i) consoles never providing support for it.</p> <p>The game has an option for changing the language (although it initially defaults to the console language, converting the firmware value to this values), so Dutch can be chosen there by the end user.</p>"},{"location":"files/font/","title":"Font file","text":""},{"location":"files/font/#file-format","title":"File format","text":"<p>TODO</p>"},{"location":"files/font/#fonts","title":"Fonts","text":"Font description File ID Width Height \"Default\" font, large 891 15 22 \"Default\" font, medium 893 11 14 \"Default\" font, small 896 9 12 \"Default\" font variant, large 892 15 22 \"Default\" font variant, medium 894 11 14 \"Default\" font variant, small 897 9 12 \"Alternative\" font 895 6 8"},{"location":"files/input-dictionary/","title":"Input dictionary files","text":"<p>This page describes the various file formats that together form a list/table/dictionary containing object/adjective entries.</p>"},{"location":"files/input-dictionary/#nomenclature","title":"Nomenclature","text":"<p>In order to avoid any mixups with objects, adjectives and so on, the following terms are used throughout this docs:</p> <ul> <li> <p>Input: generic term describing either objects or adjectives (note that they may even individually contain multiple words, like <code>ROCKET LAUNCHER</code>), as in the literal input typed in Maxwell's notebook.</p> </li> <li> <p>Object and Adjective: these are rather self explanatory, the two kinds of inputs the game supports.</p> </li> <li> <p>Match: actual object/adjective entry: the same input might correspond to multiple matches, like <code>AMAZON</code> can be either the rainforest or the native people.</p> </li> <li> <p>Description: additional text used by the game to distinguish matches: for example, <code>AMAZON</code> can be either <code>PLACE</code> or <code>PERSON</code>, as just mentioned above. The text is displayed in-game in parentheses, as in like <code>AMAZON (PLACE)</code>.</p> </li> </ul> <p>Note: all these names are obviously unofficial, as well as the file format naming used below (and pretty much in the overall documentation)</p>"},{"location":"files/input-dictionary/#files","title":"Files","text":"<p>For each language, both for objects and adjectives (separately), the game stores dictionary data in three different but related files (four for objects):</p> <ul> <li> <p>Input list file: contains the actual input entries.</p> </li> <li> <p>\"Lookup\" offset list file: contains offsets to entries in the input list file.</p> </li> <li> <p>\"Match\" offset list file: contains offsets to entries in the input list file.</p> </li> <li> <p>Both offset list files have the same format, and essentially order/index inputs in different orderings. The \"lookup\" file lists them in alphabetical order, while the \"match\" file lists them in a somewhat arbitrary ordering, even containing empty input entries (see below).</p> </li> </ul> <p>Note: the \"match\" list seems to contain input entries as the developers kept creating and adding them, since they seem to be clustered around particular topics: for instance, the first blob of non-empty inputs are all musical instruments, and similar topics arise throughout the list. Moreover, the empty input entries probably correspond to old/dev/beta/testing inputs that were discarded throughout development.</p> <ul> <li>Match description list file (only for objects): contains description texts for inputs with multiple matches.</li> </ul> <p>Note: despite having remarkably different roles in the game logic, objects and adjectives are treated together here since they practically share the same formats described in this page. In fact, game code contains four functions to get the hardcoded file ID for each file according to the system language, where for the three common object/adjective files, the functions take a <code>bool is_object</code> argument whether to return object or adjective dictionary file IDs.</p> <p>Note: file IDs for lookup offset list files are far beyond the other mentioned files (for all languages), which might suggest that this list/ordering was added late into development.</p>"},{"location":"files/input-dictionary/#input-list-file-format","title":"Input list file format","text":""},{"location":"files/input-dictionary/#character-dictionary","title":"Character dictionary","text":"<p>The file starts with a \"character dictionary\" section:</p> <pre><code>u8 char_dict_len;\nchar char_dict[char_dict_len];\nu32 input_entry_count;\nu32 input_entry_start_offset_2d_table[char_dict_len * char_dict_len];\n</code></pre> <p>The character dictionary consists on a list of characters, that inputs below may start with: for instance, \"ABCDEFG...\".</p> <p>The dictionary is followed by the total number of input entries (coming after this section), and by a bi-dimensional array with entries for each character in the dictionary consisting on 32-bit absolute offsets of input entries below.</p> <p>For instance, if the dictionary had five characters \"ABCDE\", the bi-dimensional table would be an array of <code>5*5 = 25</code> 32-bit offsets, and it shall be understood in the following way:</p> A B C D E A Offset to first input with name \"AA...\" Same for \"AB...\" Same for \"AC...\" Same for \"AD...\" Same for \"AE...\" B Same for \"BA...\" Same for \"BB...\" Same for \"BC...\" Same for \"BD...\" Same for \"BE...\" C Same for \"CA...\" Same for \"CB...\" Same for \"CC...\" Same for \"CD...\" Same for \"CE...\" D Same for \"DA...\" Same for \"DB...\" Same for \"DC...\" Same for \"DD...\" Same for \"DE...\" E Same for \"EA...\" Same for \"EB...\" Same for \"EC...\" Same for \"ED...\" Same for \"EE...\" <p>Thus, the offset to the table offset for a two-letter prefix <code>MN...</code> is calculated by (as the game itself computes):</p> <pre><code>u32 offset_offset(MN) = (0x01 + 0x01 * Character count + 0x04) + 0x04 * (index(M) * &lt;character-count&gt; + index(N));\n</code></pre> <p>Where <code>index(X)</code> corresponds to the index of the letter <code>X</code> in the dictionary above (in game code, such an index is computed by a searching loop over dictionary characters).</p> <p>This system is likely intended for a quick lookup of inputs based on the first two letters of the input text.</p>"},{"location":"files/input-dictionary/#input-entry","title":"Input entry","text":"<p>Each input entry follows the following format (and follow one after each other without any alignment/padding, as per usual with other file formats):</p> <pre><code>u8 total_entry_size;\nu8 input_text_len;\nchar input_text[input_text_len];\nu16 lookup_list_idx;\nu16 unk_zero;\nu8 match_count;\nu16 file_id_per_match[match_count];\nu16 match_list_idx_per_match[match_count];\nu16 unk_per_match[match_count];\n</code></pre> <p>TODO: is total entry size used by the game?</p> <p>Note: keep in mind that the way fields are stored for each match is not the usual one! all the fields are laid out as individual arrays (unlike regular behaviour when having an array of plain data structures, for instance)</p>"},{"location":"files/input-dictionary/#input-offset-list-file-format","title":"Input offset list file format","text":"<p>These files just contain <code>u32</code> absolute input entry offsets for their corresponding input list file.</p> <p>The offset count doesn't have to match the actual input/total match count, since the files may contain invalid offsets: any zero-offset makes no sense as a file. The game explicitly checks that <code>offset != 0</code> when reading inputs, which shows that any zero-offsets indeed correspond to invalid/empty input entries in this lists.</p> <p>For \"match\" offset lists, note that the offset might point to a different input. For instance, there is an input entry for <code>BOG</code> with a single match, and that match's entry in the \"match\" list offset file points to a different input entry, the one for <code>SWAMP</code>: this obviously serves as a multi-word mechanism, so that multiple inputs can be dealt with a single root input (think <code>PASTA</code>, and then many kinds of pasta like <code>MACARONI</code>, <code>FUSILLI</code>, <code>RIGATONI</code> merely point to <code>PASTA</code>), since the game ultimately seems to load object/adjective data based on \"match\" list offset entries.</p>"},{"location":"files/input-dictionary/#match-description-list-file-format","title":"Match description list file format","text":""},{"location":"files/input-dictionary/#character-dictionary_1","title":"Character dictionary","text":"<p>This format also starts with a character dictionary + offset lookup table, similar to input list files:</p> <pre><code>u8 char_dict_len;\nchar char_dict[char_dict_len];\nu32 desc_entry_start_offset_table[char_dict_len];\n</code></pre> <p>Unlike with input list files, no total entry count is provided, and the lookup table is one-dimensional, providing lookup based on the first character of the input text.</p> <p>Note: the game never loads these files entry by entry in order to find the description of the matches of a given input: instead, it jumps to the first-letter offset by the lookup table, and then compares the input name to each description entry, checking entry by entry (which is why there is no real need of an \"entry count\" field) until it is found</p>"},{"location":"files/input-dictionary/#description-entry","title":"Description entry","text":"<p>Each input entry follows the following format (and follow one after each other without any alignment/padding, as per usual):</p> <pre><code>u8 input_text_len;\nchar input_text[input_text_len];\nu8 match_desc_count;\nu16 unk_per_match[match_count];\nu8 match_desc_len_per_match[match_count];\nchar match_desc_per_match[match_desc_len_per_match][match_count];\n</code></pre>"},{"location":"files/input-dictionary/#input-dictionaries","title":"Input dictionaries","text":""},{"location":"files/input-dictionary/#objects","title":"Objects","text":"Language Input list file ID \"Lookup\" offset list file ID \"Match\" offset file ID Match description list file ID English 13220 32173 13251 13236 Dutch 13228 32171 13250 13235 French 13225 32175 13253 13238 German 13219 32176 13255 13240 Italian 13227 32177 13256 13241 Spanish 13221 32180 13262 13246 Unknown 24063 32172 24064 24073"},{"location":"files/input-dictionary/#adjectives","title":"Adjectives","text":"Language Input list file ID \"Lookup\" offset list file ID \"Match\" offset file ID English 13267 32161 13282 Dutch 13275 32159 13281 French 13272 32163 13284 German 13266 32164 13290 Italian 13274 32165 13291 Spanish 13268 32168 13295 Unknown 24074 32160 24075"},{"location":"files/text-list/","title":"Text list file","text":""},{"location":"files/text-list/#file-format","title":"File format","text":"<p>Files containing texts/messages have the following format:</p> <pre><code>u8 text_count_per_lang;\n{\n    char text_1[...];\n    char '\\n';\n    char text_2[...];\n    char '\\n';\n    // ...\n} texts_english;\n{\n    // ...\n} texts_dutch;\n\n// ...\n</code></pre> <p>There is an initial byte containing the number of texts (per language). The remaining contents are all text strings, separated by newlines (character <code>0x0A</code> or <code>'\\n'</code>). No further separation is done to indicate which strings belong to which language, they are all in order: all English strings, followed by all Dutch strings and so on (see languages) for each language.</p> <p>Note that, like with filesystem offsets, the last string will also end in a newline (basically, the newline is the ending indicator for every string).</p>"},{"location":"files/text-list/#text-format-escapes","title":"Text format / escapes","text":"<p>A unique property of Super Scribblenauts' strings is that they are all always uppercase (take a look at every single dialog/message/button when playing the game).</p> <p>This is, in fact, somewhat intentional or taken advantage of: certain lowercase characters are internally parsed as special operations on the string:</p> Character Action Example text c Center cDEMOc i Use alternative font iDEMOi l Use large \"default\" font lDEMOl m Use medium \"default\" font mDEMOm n Align left nDEMOn o Align right oDEMOo <p>Note that, by default, the start \"default\" font is used (see fonts).</p> <p>There is still no clear difference between texts that only start with the escape characters (like \"ciHELLO\") as opposed to texts that start and end with it (like \"ciHELLOic\", or maybe even \"ciHELLOci\"...?).</p>"},{"location":"files/text-list/#text-list-files","title":"Text list files","text":"<p>TODO</p>"}]}